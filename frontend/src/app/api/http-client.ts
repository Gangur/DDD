//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';
import { toast } from 'react-toastify';
import { router } from '../router/Routes';

export class Client {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return Success
     */
    v1BuggyNotFound(cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/buggy/not-found";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1BuggyNotFound(_response);
        });
    }

    protected processV1BuggyNotFound(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    v1BuggyBadRequest(cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/buggy/bad-request";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1BuggyBadRequest(_response);
        });
    }

    protected processV1BuggyBadRequest(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    v1BuggyUnauthorized(cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/buggy/unauthorized";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1BuggyUnauthorized(_response);
        });
    }

    protected processV1BuggyUnauthorized(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    v1BuggyValidationProblem(cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/buggy/validation-problem";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1BuggyValidationProblem(_response);
        });
    }

    protected processV1BuggyValidationProblem(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    v1BuggyServerError(cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/buggy/server-error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1BuggyServerError(_response);
        });
    }

    protected processV1BuggyServerError(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    v1CustomeresCreate(email: string, name: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/customeres/create?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1CustomeresCreate(_response);
        });
    }

    protected processV1CustomeresCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    v1Customeres(id: string, cancelToken?: CancelToken): Promise<CustomerDto> {
        let url_ = this.baseUrl + "/v1/customeres/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1Customeres(_response);
        });
    }

    protected processV1Customeres(response: AxiosResponse): Promise<CustomerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerDto>(null as any);
    }

    /**
     * @return Success
     */
    v1CustomeresList(cancelToken?: CancelToken): Promise<CustomerDto[]> {
        let url_ = this.baseUrl + "/v1/customeres/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1CustomeresList(_response);
        });
    }

    protected processV1CustomeresList(response: AxiosResponse): Promise<CustomerDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerDto[]>(null as any);
    }

    /**
     * @return Success
     */
    v1CustomeresDelete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/customeres/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1CustomeresDelete(_response);
        });
    }

    protected processV1CustomeresDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    v1FilesUpload(body: Body | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/files/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "multipart/form-data; x-api-version=1.0",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1FilesUpload(_response);
        });
    }

    protected processV1FilesUpload(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    v1FilesDownload(fileName: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/files/download?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1FilesDownload(_response);
        });
    }

    protected processV1FilesDownload(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    v1OrdersCreate(customerId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/orders/create?";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined and cannot be null.");
        else
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1OrdersCreate(_response);
        });
    }

    protected processV1OrdersCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    v1OrdersRemoveLineItem(orderId: string, lineItemId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/orders/remove-line-item?";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined and cannot be null.");
        else
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        if (lineItemId === undefined || lineItemId === null)
            throw new Error("The parameter 'lineItemId' must be defined and cannot be null.");
        else
            url_ += "lineItemId=" + encodeURIComponent("" + lineItemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1OrdersRemoveLineItem(_response);
        });
    }

    protected processV1OrdersRemoveLineItem(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    v1OrdersAddLineItem(orderId: string, productId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/orders/add-line-item?";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined and cannot be null.");
        else
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined and cannot be null.");
        else
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1OrdersAddLineItem(_response);
        });
    }

    protected processV1OrdersAddLineItem(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    v1Orders(id: string, cancelToken?: CancelToken): Promise<OrderDto> {
        let url_ = this.baseUrl + "/v1/orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1Orders(_response);
        });
    }

    protected processV1Orders(response: AxiosResponse): Promise<OrderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OrderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderDto>(null as any);
    }

    /**
     * @return Success
     */
    v1OrdersByCustomer(customerId: string, cancelToken?: CancelToken): Promise<OrderDto> {
        let url_ = this.baseUrl + "/v1/orders/by-customer/{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1OrdersByCustomer(_response);
        });
    }

    protected processV1OrdersByCustomer(response: AxiosResponse): Promise<OrderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OrderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderDto>(null as any);
    }

    /**
     * @return Success
     */
    v1OrdersList(cancelToken?: CancelToken): Promise<OrderDto[]> {
        let url_ = this.baseUrl + "/v1/orders/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1OrdersList(_response);
        });
    }

    protected processV1OrdersList(response: AxiosResponse): Promise<OrderDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OrderDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderDto[]>(null as any);
    }

    /**
     * @param name (optional) 
     * @param priceCurrency (optional) 
     * @param brandName (optional) 
     * @param priceAmount (optional) 
     * @param pictureName (optional) 
     * @param sku (optional) 
     * @param category (optional) 
     * @return Success
     */
    v1ProductsCreate(name: string | undefined, priceCurrency: string | undefined, brandName: string | undefined, priceAmount: number | undefined, pictureName: string | undefined, sku: string | undefined, category: Category | undefined, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/v1/products/create?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (priceCurrency === null)
            throw new Error("The parameter 'priceCurrency' cannot be null.");
        else if (priceCurrency !== undefined)
            url_ += "priceCurrency=" + encodeURIComponent("" + priceCurrency) + "&";
        if (brandName === null)
            throw new Error("The parameter 'brandName' cannot be null.");
        else if (brandName !== undefined)
            url_ += "brandName=" + encodeURIComponent("" + brandName) + "&";
        if (priceAmount === null)
            throw new Error("The parameter 'priceAmount' cannot be null.");
        else if (priceAmount !== undefined)
            url_ += "priceAmount=" + encodeURIComponent("" + priceAmount) + "&";
        if (pictureName === null)
            throw new Error("The parameter 'pictureName' cannot be null.");
        else if (pictureName !== undefined)
            url_ += "pictureName=" + encodeURIComponent("" + pictureName) + "&";
        if (sku === null)
            throw new Error("The parameter 'sku' cannot be null.");
        else if (sku !== undefined)
            url_ += "sku=" + encodeURIComponent("" + sku) + "&";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1ProductsCreate(_response);
        });
    }

    protected processV1ProductsCreate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    v1Products(id: string, cancelToken?: CancelToken): Promise<ProductDto> {
        let url_ = this.baseUrl + "/v1/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1Products(_response);
        });
    }

    protected processV1Products(response: AxiosResponse): Promise<ProductDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ProductDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDto>(null as any);
    }

    /**
     * @return Success
     */
    v1ProductsList(cancelToken?: CancelToken): Promise<ProductDto[]> {
        let url_ = this.baseUrl + "/v1/products/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processV1ProductsList(_response);
        });
    }

    protected processV1ProductsList(response: AxiosResponse): Promise<ProductDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ProductDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDto[]>(null as any);
    }
}

export enum Category {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export interface CustomerDto {
    id?: string;
    email?: string | undefined;
    name?: string | undefined;
}

export interface LineItemDto {
    productId?: string;
    quantity?: number;
}

export interface OrderDto {
    id?: string;
    customerId?: string;
    lineItems?: LineItemDto[] | undefined;
}

export interface ProductDto {
    id?: string;
    name?: string | undefined;
    brand?: string | undefined;
    pictureName?: string | undefined;
    priceCurrency?: string | undefined;
    priceAmount?: number;
    sku?: string | undefined;
    category?: string | undefined;
}

export interface Body {
    file: string;

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    var data = JSON.parse(response);
    if (result !== null && result !== undefined)
        throw result;
    else
        switch (status) {
            case 400:
                if (data.errors) {
                    const modelStateErrors: string[] = [];
                    for (const key in data.errors) {
                        modelStateErrors.push(data.errors[key])
                    }
                    throw modelStateErrors.flat();
                }
                break;
            case 401:
                toast.error(data.title)
                break;
            case 500:
                router.navigate('/server-error', { state: { error: data } })
                break;
            default:
                break;
        }
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}