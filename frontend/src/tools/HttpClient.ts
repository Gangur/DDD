//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class Client {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return Success
     */
    customerV1Create(email: string, name: string, cancelToken?: CancelToken): Promise<Result> {
        let url_ = this.baseUrl + "/customer/v1/create?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerV1Create(_response);
        });
    }

    protected processCustomerV1Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    /**
     * @return Success
     */
    customerV1Get(id: string, cancelToken?: CancelToken): Promise<CustomerDtoResult> {
        let url_ = this.baseUrl + "/customer/v1/get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerV1Get(_response);
        });
    }

    protected processCustomerV1Get(response: AxiosResponse): Promise<CustomerDtoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerDtoResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerDtoResult>(null as any);
    }

    /**
     * @return Success
     */
    customerV1List(cancelToken?: CancelToken): Promise<CustomerDtoIReadOnlyCollectionResult> {
        let url_ = this.baseUrl + "/customer/v1/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerV1List(_response);
        });
    }

    protected processCustomerV1List(response: AxiosResponse): Promise<CustomerDtoIReadOnlyCollectionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerDtoIReadOnlyCollectionResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerDtoIReadOnlyCollectionResult>(null as any);
    }

    /**
     * @return Success
     */
    customerV1Delete(id: string, cancelToken?: CancelToken): Promise<Result> {
        let url_ = this.baseUrl + "/customer/v1/delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerV1Delete(_response);
        });
    }

    protected processCustomerV1Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    filesV1Upload(body: Body | undefined, cancelToken?: CancelToken): Promise<Result> {
        let url_ = this.baseUrl + "/files/v1/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "multipart/form-data; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilesV1Upload(_response);
        });
    }

    protected processFilesV1Upload(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    /**
     * @return Success
     */
    filesV1Download(fileName: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/files/v1/download?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilesV1Download(_response);
        });
    }

    protected processFilesV1Download(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    ordersV1Create(customerId: string, cancelToken?: CancelToken): Promise<Result> {
        let url_ = this.baseUrl + "/orders/v1/create?";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined and cannot be null.");
        else
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersV1Create(_response);
        });
    }

    protected processOrdersV1Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    /**
     * @return Success
     */
    ordersV1RemoveLineItem(orderId: string, lineItemId: string, cancelToken?: CancelToken): Promise<Result> {
        let url_ = this.baseUrl + "/orders/v1/remove-line-item?";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined and cannot be null.");
        else
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        if (lineItemId === undefined || lineItemId === null)
            throw new Error("The parameter 'lineItemId' must be defined and cannot be null.");
        else
            url_ += "lineItemId=" + encodeURIComponent("" + lineItemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersV1RemoveLineItem(_response);
        });
    }

    protected processOrdersV1RemoveLineItem(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    /**
     * @return Success
     */
    ordersV1Get(id: string, cancelToken?: CancelToken): Promise<OrderDtoResult> {
        let url_ = this.baseUrl + "/orders/v1/get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersV1Get(_response);
        });
    }

    protected processOrdersV1Get(response: AxiosResponse): Promise<OrderDtoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OrderDtoResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderDtoResult>(null as any);
    }

    /**
     * @return Success
     */
    ordersV1List(cancelToken?: CancelToken): Promise<OrderDtoIReadOnlyCollectionResult> {
        let url_ = this.baseUrl + "/orders/v1/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersV1List(_response);
        });
    }

    protected processOrdersV1List(response: AxiosResponse): Promise<OrderDtoIReadOnlyCollectionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OrderDtoIReadOnlyCollectionResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderDtoIReadOnlyCollectionResult>(null as any);
    }

    /**
     * @param name (optional) 
     * @param priceCurrency (optional) 
     * @param priceAmount (optional) 
     * @param pictureName (optional) 
     * @param sku (optional) 
     * @return Success
     */
    productV1Create(name: string | undefined, priceCurrency: string | undefined, priceAmount: number | undefined, pictureName: string | undefined, sku: string | undefined, cancelToken?: CancelToken): Promise<GuidResult> {
        let url_ = this.baseUrl + "/product/v1/create?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (priceCurrency === null)
            throw new Error("The parameter 'priceCurrency' cannot be null.");
        else if (priceCurrency !== undefined)
            url_ += "priceCurrency=" + encodeURIComponent("" + priceCurrency) + "&";
        if (priceAmount === null)
            throw new Error("The parameter 'priceAmount' cannot be null.");
        else if (priceAmount !== undefined)
            url_ += "priceAmount=" + encodeURIComponent("" + priceAmount) + "&";
        if (pictureName === null)
            throw new Error("The parameter 'pictureName' cannot be null.");
        else if (pictureName !== undefined)
            url_ += "pictureName=" + encodeURIComponent("" + pictureName) + "&";
        if (sku === null)
            throw new Error("The parameter 'sku' cannot be null.");
        else if (sku !== undefined)
            url_ += "sku=" + encodeURIComponent("" + sku) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProductV1Create(_response);
        });
    }

    protected processProductV1Create(response: AxiosResponse): Promise<GuidResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<GuidResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GuidResult>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    productV1Get(id: string | undefined, cancelToken?: CancelToken): Promise<ProductDtoResult> {
        let url_ = this.baseUrl + "/product/v1/get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProductV1Get(_response);
        });
    }

    protected processProductV1Get(response: AxiosResponse): Promise<ProductDtoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ProductDtoResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDtoResult>(null as any);
    }

    /**
     * @return Success
     */
    productV1List(cancelToken?: CancelToken): Promise<ProductDtoIReadOnlyCollectionResult> {
        let url_ = this.baseUrl + "/product/v1/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain; x-api-version=1.0"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProductV1List(_response);
        });
    }

    protected processProductV1List(response: AxiosResponse): Promise<ProductDtoIReadOnlyCollectionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ProductDtoIReadOnlyCollectionResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDtoIReadOnlyCollectionResult>(null as any);
    }
}

export interface CustomerDto {
    id?: string;
    email?: string | undefined;
    name?: string | undefined;
}

export interface CustomerDtoIReadOnlyCollectionResult {
    success?: boolean;
    errorMessage?: string | undefined;
    value?: CustomerDto[] | undefined;
}

export interface CustomerDtoResult {
    success?: boolean;
    errorMessage?: string | undefined;
    value?: CustomerDto;
}

export interface GuidResult {
    success?: boolean;
    errorMessage?: string | undefined;
    value?: string;
}

export interface OrderDto {
    id?: string;
    customerId?: string;
}

export interface OrderDtoIReadOnlyCollectionResult {
    success?: boolean;
    errorMessage?: string | undefined;
    value?: OrderDto[] | undefined;
}

export interface OrderDtoResult {
    success?: boolean;
    errorMessage?: string | undefined;
    value?: OrderDto;
}

export interface ProductDto {
    id?: string;
    name?: string | undefined;
    pictureName?: string | undefined;
    priceCurrency?: string | undefined;
    priceAmount?: number;
    sku?: string | undefined;
}

export interface ProductDtoIReadOnlyCollectionResult {
    success?: boolean;
    errorMessage?: string | undefined;
    value?: ProductDto[] | undefined;
}

export interface ProductDtoResult {
    success?: boolean;
    errorMessage?: string | undefined;
    value?: ProductDto;
}

export interface Result {
    success?: boolean;
    errorMessage?: string | undefined;
}

export interface Body {
    file: string;

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}